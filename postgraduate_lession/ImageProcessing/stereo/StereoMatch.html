<!DOCTYPE html>
<html>
<head>
<title>StereoMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1>更多内容请前往Github搜索tangjiafu或者ImageProcessing_Tang</h1>
<h4>特别感谢OPENCV提供的源码####</h4>
<pre><code>  #include &quot;opencv2/calib3d/calib3d.hpp&quot;
  #include &quot;opencv2/imgproc/imgproc.hpp&quot;
  #include &quot;opencv2/imgcodecs.hpp&quot;
  #include &quot;opencv2/highgui/highgui.hpp&quot;
  #include &quot;opencv2/core/utility.hpp&quot;             //调用opencv3.1图像处理库的头文件

  #include &lt;stdio.h&gt;    //C++输出输出函数的库

  using namespace cv;   //去除opencv库的函数的CV::

  static void print_help()  //控制台程序帮助函数
  {
    printf(&quot;\nDemo stereo matching converting L and R images into disparity and point clouds\n&quot;);
    printf(&quot;\nUsage: stereo_match &lt;left_image&gt; &lt;right_image&gt; [--algorithm=bm|sgbm|hh|sgbm3way] [--blocksize=&lt;block_size&gt;]\n&quot;
        &quot;[--max-disparity=&lt;max_disparity&gt;] [--scale=scale_factor&gt;] [-i=&lt;intrinsic_filename&gt;] [-e=&lt;extrinsic_filename&gt;]\n&quot;
        &quot;[--no-display] [-o=&lt;disparity_image&gt;] [-p=&lt;point_cloud_file&gt;]\n&quot;);
  }
  static void saveXYZ(const char* filename, const Mat&amp; mat)  //储存XYZ三维空间坐标点，按行储存，每一行是一个坐标点，X,Y,Z    
  //按行读取，储存成为一个链表。注意matlab里面是按列读取
  {
    const double max_z = 1.0e4;
    FILE* fp = fopen(filename, &quot;wt&quot;);
    for (int y = 0; y &lt; mat.rows; y++)
    {
        for (int x = 0; x &lt; mat.cols; x++)
        {
            Vec3f point = mat.at&lt;Vec3f&gt;(y, x);  //Vec3f变量是为三维空间坐标点储存矩阵
            if (fabs(point[2] - max_z) &lt; FLT_EPSILON || fabs(point[2]) &gt; max_z) continue;
            fprintf(fp, &quot;%f %f %f\n&quot;, point[0], point[1], point[2]);
        }
    }
    fclose(fp);
  }

  int main(int argc, char** argv)
  {
    std::string img1_filename = &quot;&quot;;           //图片文件1
    std::string img2_filename = &quot;&quot;;           //图片文件2
    std::string intrinsic_filename = &quot;&quot;;      //内部参数矩阵文件
    std::string extrinsic_filename = &quot;&quot;;      //外部参数矩阵文件
    std::string disparity_filename = &quot;&quot;;      //视差文件
    std::string point_cloud_filename = &quot;&quot;;    //点云文件   //参数在这里设置

    enum { STEREO_BM = 0, STEREO_SGBM = 1, STEREO_HH = 2, STEREO_VAR = 3, STEREO_3WAY = 4 };//匹配方法选择
    int alg = STEREO_SGBM;   //默认方法为SGBM
    int SADWindowSize, numberOfDisparities;
    bool no_display;   //布尔变量，决定是否显示
    float scale;      //尺度因子

    Ptr&lt;StereoBM&gt; bm = StereoBM::create(16, 9);//创建BM匹配方法，变量名为bm
    Ptr&lt;StereoSGBM&gt; sgbm = StereoSGBM::create(0, 16, 3);  //创建SGBM匹配方法，变量名为SGBM
    cv::CommandLineParser parser(argc, argv,
        &quot;{max-disparity|64|}{blocksize|7|}{no-display||}{scale|1|}{help||}{algorithm|sgbm|}{@left|left01.jpg|}{@right|right01.jpg|}{i|intrinsics.xml|}{e|extrinsics.xml|}{o|disparity.xml|}{p|point.dat|}&quot;);
    //  &quot;{help h||}{algorithm||}{max-disparity|0|}{blocksize|0|}{no-display||}{scale|1|}{i||}{e||}{o||}{p||}&quot;); //此行需要修改参数在这里设置
    //此行视作为批量宏定义，｛name|value|｝是一个定义变量名|变量值| 
    //下面若干行程序，将这些宏定义转化为实际的程序赋值和调用，其中包括一些check
    if (parser.has(&quot;help&quot;))
    {
        print_help();
        return 0;
    }
    img1_filename = parser.get&lt;std::string&gt;(&quot;@left&quot;);
    img2_filename = parser.get&lt;std::string&gt;(&quot;@right&quot;);
    if (parser.has(&quot;algorithm&quot;))
    {
        std::string _alg = parser.get&lt;std::string&gt;(&quot;algorithm&quot;); //这几行程序非常关键，逻辑极其复杂，注意是?号三目运算符的嵌套，
        alg = _alg == &quot;bm&quot; ? STEREO_BM :                         //
            _alg == &quot;sgbm&quot; ? STEREO_SGBM :                       //
            _alg == &quot;hh&quot; ? STEREO_HH :                           //
            _alg == &quot;var&quot; ? STEREO_VAR :                         //
            _alg == &quot;sgbm3way&quot; ? STEREO_3WAY : -1;               //
    }                                                            //注意，可以转换为即为C中的switch语句                                                                               、
    numberOfDisparities = parser.get&lt;int&gt;(&quot;max-disparity&quot;);
    SADWindowSize = parser.get&lt;int&gt;(&quot;blocksize&quot;);
    scale = parser.get&lt;float&gt;(&quot;scale&quot;);
    no_display = parser.has(&quot;no-display&quot;);
    if (parser.has(&quot;i&quot;))
        intrinsic_filename = parser.get&lt;std::string&gt;(&quot;i&quot;);
    if (parser.has(&quot;e&quot;))
        extrinsic_filename = parser.get&lt;std::string&gt;(&quot;e&quot;);
    if (parser.has(&quot;o&quot;))
        disparity_filename = parser.get&lt;std::string&gt;(&quot;o&quot;);
    if (parser.has(&quot;p&quot;))
        point_cloud_filename = parser.get&lt;std::string&gt;(&quot;p&quot;);
    if (!parser.check())
    {
        parser.printErrors();
        return 1;
    }
    if (alg &lt; 0)                //以上为CommandLineParser类的具体调用，赋值，下面为check,仔细核对是否为空或者满足程序逻辑要求，保证不会出现程序中断
    {
        printf(&quot;Command-line parameter error: Unknown stereo algorithm\n\n&quot;);
        print_help();
        return -1;
    }
    if (numberOfDisparities &lt; 1 || numberOfDisparities % 16 != 0)
    {
        printf(&quot;Command-line parameter error: The max disparity (--maxdisparity=&lt;...&gt;) must be a positive integer divisible by 16\n&quot;);
        print_help();
        return -1;
    }
    if (scale &lt; 0)
    {
        printf(&quot;Command-line parameter error: The scale factor (--scale=&lt;...&gt;) must be a positive floating-point number\n&quot;);
        return -1;
    }
    if (SADWindowSize &lt; 1 || SADWindowSize % 2 != 1)                           //保证SAD窗口边长为奇数
    {
        printf(&quot;Command-line parameter error: The block size (--blocksize=&lt;...&gt;) must be a positive odd number\n&quot;);
        return -1;
    }
    if (img1_filename.empty() || img2_filename.empty())                        //保证图片1，2文件都存在
    {
        printf(&quot;Command-line parameter error: both left and right images must be specified\n&quot;);
        return -1;
    }
    if ((!intrinsic_filename.empty()) ^ (!extrinsic_filename.empty()))        //保证内部外部参数矩阵文件存在
    {
        printf(&quot;Command-line parameter error: either both intrinsic and extrinsic parameters must be specified, or none of them (when the stereo pair is already rectified)\n&quot;);
        return -1;
    }

    if (extrinsic_filename.empty() &amp;&amp; !point_cloud_filename.empty())   //保证外部参数和点云矩阵的外部参数文件路径存在
    {
        printf(&quot;Command-line parameter error: extrinsic and intrinsic parameters must be specified to compute the point cloud\n&quot;);
        return -1;
    }

    int color_mode = alg == STEREO_BM ? 0 : -1;     //imread(filepath,flag)   flag&gt;0, 该函数返回3通道图像，如果磁盘上的图像文件是单通道的灰度图像，则会被强制转为3通道；
    //                         flag = 0, 该函数返回单通道图像，如果磁盘的图像文件是多通道的则会被强制转为单通道；
    //                         flag&lt;0, 则函数不对图像进行通道转换
    Mat img1 = imread(img1_filename, color_mode);
    Mat img2 = imread(img2_filename, color_mode);

    if (img1.empty())    //check 图片1是否存在
    {
        printf(&quot;Command-line parameter error: could not load the first input image file\n&quot;);
        return -1;
    }
    if (img2.empty())    //check  图片2是否存在  
    {
        printf(&quot;Command-line parameter error: could not load the second input image file\n&quot;);
        return -1;
    }

    if (scale != 1.f)    //scale默认设置1.0，说明该if语句默认不执行
    {
        Mat temp1, temp2;
        int method = scale &lt; 1 ? INTER_AREA : INTER_CUBIC;
        resize(img1, temp1, Size(), scale, scale, method);
        img1 = temp1;
        resize(img2, temp2, Size(), scale, scale, method);
        img2 = temp2;
    }

    Size img_size = img1.size();

    Rect roi1, roi2;    //判断满足校正后的区域
    Mat Q;

    if (!intrinsic_filename.empty())   //读取内部参数.xml文件中的M1,D1,M2,D2;并将参数存储在M1,D1,M2,D2变量中
    {
        // reading intrinsic parameters
        FileStorage fs(intrinsic_filename, FileStorage::READ);
        if (!fs.isOpened())
        {
            printf(&quot;Failed to open file %s\n&quot;, intrinsic_filename.c_str());
            return -1;
        }

        Mat M1, D1, M2, D2;
        fs[&quot;M1&quot;] &gt;&gt; M1;
        fs[&quot;D1&quot;] &gt;&gt; D1;
        fs[&quot;M2&quot;] &gt;&gt; M2;
        fs[&quot;D2&quot;] &gt;&gt; D2;

        M1 *= scale;  //乘以尺度因子，默认为1.0
        M2 *= scale;

        fs.open(extrinsic_filename, FileStorage::READ);//读取外部参数.xml文件,并将R,T存储在R,T矩阵变量中
        if (!fs.isOpened())
        {
            printf(&quot;Failed to open file %s\n&quot;, extrinsic_filename.c_str());
            return -1;
        }

        Mat R, T, R1, P1, R2, P2;
        fs[&quot;R&quot;] &gt;&gt; R;
        fs[&quot;T&quot;] &gt;&gt; T;

        stereoRectify(M1, D1, M2, D2, img_size, R, T, R1, R2, P1, P2, Q, CALIB_ZERO_DISPARITY, -1, img_size, &amp;roi1, &amp;roi2);       //调用校正函数，求参数R1,P1,R2,P2,Q

        Mat map11, map12, map21, map22;       //映射矩阵
        initUndistortRectifyMap(M1, D1, R1, P1, img_size, CV_16SC2, map11, map12);//利用R1,P1,内部参数M1,D1，求映射矩阵
        initUndistortRectifyMap(M2, D2, R2, P2, img_size, CV_16SC2, map21, map22);//利用R1,P1,内部参数M1,D1 ，求映射矩阵

        Mat img1r, img2r;
        remap(img1, img1r, map11, map12, INTER_LINEAR);//利用映射矩阵进行图片校正
        remap(img2, img2r, map21, map22, INTER_LINEAR);//利用映射矩阵进行图片校正

        img1 = img1r;
        img2 = img2r;
    }

    numberOfDisparities = numberOfDisparities &gt; 0 ? numberOfDisparities : ((img_size.width / 8) + 15) &amp; -16;//各种匹配方法共同的参数设置

    bm-&gt;setROI1(roi1);                                      //下面为BM匹配方法的参数设置，这里将校正得到的有效区域传入匹配中
    bm-&gt;setROI2(roi2);                                      //
    bm-&gt;setPreFilterCap(31);                                //
    bm-&gt;setBlockSize(SADWindowSize &gt; 0 ? SADWindowSize : 9);//
    bm-&gt;setMinDisparity(0);                                 //
    bm-&gt;setNumDisparities(numberOfDisparities);             //
    bm-&gt;setTextureThreshold(10);                            //
    bm-&gt;setUniquenessRatio(15);                             //
    bm-&gt;setSpeckleWindowSize(100);                          //
    bm-&gt;setSpeckleRange(32);                                //
    bm-&gt;setDisp12MaxDiff(1);                                //

    sgbm-&gt;setPreFilterCap(63);                                    //下面数行将SGBM方法的参数设置，
    int sgbmWinSize = SADWindowSize &gt; 0 ? SADWindowSize : 3;      //
    sgbm-&gt;setBlockSize(sgbmWinSize);                              //
    //
    int cn = img1.channels();                                     //
    //
    sgbm-&gt;setP1(8 * cn*sgbmWinSize*sgbmWinSize);                  //
    sgbm-&gt;setP2(32 * cn*sgbmWinSize*sgbmWinSize);                 //
    sgbm-&gt;setMinDisparity(0);                                     //
    sgbm-&gt;setNumDisparities(numberOfDisparities);                 //
    sgbm-&gt;setUniquenessRatio(10);                                 //
    sgbm-&gt;setSpeckleWindowSize(100);                              //
    sgbm-&gt;setSpeckleRange(32);                                    //
    sgbm-&gt;setDisp12MaxDiff(1);                                    //
    if (alg == STEREO_HH)                                ///这个程序段，说明的是SGBM方法的不同分类，分别为HH,SGBM,SGBM_3WAY
        sgbm-&gt;setMode(StereoSGBM::MODE_HH);              ///
    else if (alg == STEREO_SGBM)                         ///
        sgbm-&gt;setMode(StereoSGBM::MODE_SGBM);            ///
    else if (alg == STEREO_3WAY)                         ///
        sgbm-&gt;setMode(StereoSGBM::MODE_SGBM_3WAY);       ///
    Mat disp, disp8;
    //Mat img1p, img2p, dispp;
    //copyMakeBorder(img1, img1p, 0, 0, numberOfDisparities, 0, IPL_BORDER_REPLICATE);
    //copyMakeBorder(img2, img2p, 0, 0, numberOfDisparities, 0, IPL_BORDER_REPLICATE);

    int64 t = getTickCount();
    if (alg == STEREO_BM)
        bm-&gt;compute(img1, img2, disp);                                        //计算bm方法得到的视差图
    else if (alg == STEREO_SGBM || alg == STEREO_HH || alg == STEREO_3WAY)
        sgbm-&gt;compute(img1, img2, disp);                                      //计算sgbm方法得到的视差图
    t = getTickCount() - t;
    printf(&quot;Time elapsed: %fms\n&quot;, t * 1000 / getTickFrequency());            //打印时间，单位为ms

    //disp = dispp.colRange(numberOfDisparities, img1p.cols);
    if (alg != STEREO_VAR)
        disp.convertTo(disp8, CV_8U, 255 / (numberOfDisparities*16.));
    else
        disp.convertTo(disp8, CV_8U);

    if (!disparity_filename.empty())                 //判断视差图矩阵存储文件是否存在
        //  FileStorage fs(disparity_filename,FileStorage::WRITE);  //FileStorage fs(intrinsic_filename, FileStorage::READ);
        printf(&quot;Write the disparity to file \n&quot;);     //printf提示调试时，控制台程序是否运行这一步，即在控制台可判断是否计算视差图
    if (!point_cloud_filename.empty())               //判断点云矩阵存储文件是否存在
    {
        printf(&quot;storing the point cloud...&quot;);       //printf提示调试时，控制台程序是否运行这一步
        fflush(stdout);
        Mat xyz;                                    //定义点云文件
        reprojectImageTo3D(disp, xyz, Q, true);     //利用视差图和矩阵Q计算三维空间点
        saveXYZ(point_cloud_filename.c_str(), xyz); //存储三维空间点到点云.xml文件中
        printf(&quot;\n&quot;);
    }
    if (!no_display)              //该if程序段用于图片显示，显示原来图片，视差图，no_display布尔变量判断是否显示，T表示不显示 
    {
        namedWindow(&quot;left&quot;, 1);
        imshow(&quot;left&quot;, img1);
        namedWindow(&quot;right&quot;, 1);
        imshow(&quot;right&quot;, img2);
        namedWindow(&quot;disparity&quot;, 0);
        imshow(&quot;disparity&quot;, disp8);
        printf(&quot;press any key to continue...&quot;);
        fflush(stdout);
        waitKey(0);
        printf(&quot;\n&quot;);
    }
    return 0;
  }
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
