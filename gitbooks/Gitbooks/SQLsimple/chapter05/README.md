## Chapter 05. 数据库基础理论

### 5.1 数据库基本概念

- **数据库**：

	数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。

- **数据库管理系统**

	 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能

### 5.2 关系型数据库

#### 5.2.1 简介

关系数据库是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示 关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。

关系模型中常用的概念：

- **关系**：一张二维表，每个关系都具有一个关系名，也就是表名
- **元组**：二维表中的一行，在数据库中被称为记录
- **属性**：二维表中的一列，在数据库中被称为字段
- **域**：属性的取值范围，也就是数据库中某一列的取值限制
- **关键字**：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成
- **关系模式**：指对关系的描述。其格式为：关系名(属性1，属性2， ... ... ，属性N)，在数据库中成为表结构

几乎所有的数据库管理系统都配备了一个开放式数据库连接（ODBC）驱动程序，令各个数据库之间得以互相集成。

典型代表有：MySQL、Oracle、Microsoft SQL Server、Access及PostgreSQL等

#### 5.2.2 特点

- 存储方式：传统的关系型数据库采用表格的储存方式，数据以行和列的方式进行存储；

- 存储结构：关系型数据库按照结构化的方法存储数据，每个数据表都必须对各个字段定义好（也就是先定义好表的结构），再根据表的结构存入数据，这样做的好处就是由于数据的形式和内容在存入数据之前就已经定义好了，所以整个数据表的可靠性和稳定性都比较高，但带来的问题就是一旦存入数据后，如果需要修改数据表的结构就会十分困难。

- 存储规范：关系型数据库为了避免重复、规范化数据以及充分利用好存储空间，把数据按照最小关系表的形式进行存储，这样数据管理的就可以变得很清晰、一目了然，当然这主要是一张数据表的情况。如果是多张表情况就不一样了，由于数据涉及到多张数据表，数据表之间存在着复杂的关系，随着数据表数量的增加，数据管理会越来越复杂。

- 扩展方式：由于关系型数据库将数据存储在数据表中，数据操作的瓶颈出现在多张数据表的操作中，而且数据表越多这个问题越严重，如果要缓解这个问题，只能提高处理能力，也就是选择速度更快性能更高的计算机，这样的方法虽然可以一定的拓展空间，但这样的拓展空间一定有非常有限的，也就是关系型数据库只具备纵向扩展能力。

- 查询方式：关系型数据库采用结构化查询语言来对数据库进行查询，SQL早已获得了各个数据库厂商的支持，成为数据库行业的标准，它能够支持数据库的CRUD（增加，查询，更新，删除）操作，具有非常强大的功能，SQL可以采用类似索引的方法来加快查询操作。

- 规范化：在数据库的设计开发过程中开发人员通常会面对同时需要对一个或者多个数据实体（包括数组、列表和嵌套数据）进行操作，这样在关系型数据库中，一个数据实体一般首先要分割成多个部分，然后再对分割的部分进行规范化，规范化以后再分别存入到多张关系型数据表中，这是一个复杂的过程。好消息是随着软件技术的发展，相当多的软件开发平台都提供一些简单的解决方法，例如，可以利用ORM层（也就是对象关系映射）来将数据库中对象模型映射到基于SQL的关系型数据库中去以及进行不同类型系统的数据之间的转换。

- 事务性：关系型数据库强调ACID规则（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）），可以满足对事务性要求较高或者需要进行复杂数据查询的数据操作，而且可以充分满足数据库操作的高性能和操作稳定性的要求。并且关系型数据库十分强调数据的强一致性，对于事务的操作有很好的支持。关系型数据库可以控制事务原子性细粒度，并且一旦操作有误或者有需要，可以马上回滚事务。

- 读写性能：关系型数据库十分强调数据的一致性，并为此降低读写性能付出了巨大的代价，虽然关系型数据库存储数据和处理数据的可靠性很不错，但一旦面对海量数据的处理的时候效率就会变得很差，特别是遇到高并发读写的时候性能就会下降的非常厉害。

- 授权方式：关系型数据库常见的有 Oracle，SQLServer，DB2，Mysql，除了Mysql大多数的关系型数据库如果要使用都需要支付一笔价格高昂的费用，即使是免费的Mysql性能也受到了诸多的限制。

#### 5.2.3 数据库的范式理论

构造数据库必须遵循一定的规则。在[关系数据库](https://baike.baidu.com/item/关系数据库/1237340)中，这种规则就是范式。范式是符合某一种级别的[关系模式](https://baike.baidu.com/item/关系模式/1237324)的集合。关系数据库中的关系必须满足一定的要求，即满足不同的范式。关系数据库有六种范式：[第一范式](https://baike.baidu.com/item/第一范式/3193590)（[1NF](https://baike.baidu.com/item/1NF/1196928)）、[第二范式](https://baike.baidu.com/item/第二范式/3193760)（2NF）、[第三范式](https://baike.baidu.com/item/第三范式/3193798)（3NF）、[第四范式](https://baike.baidu.com/item/第四范式/3193985)（4NF）、[第五范式](https://baike.baidu.com/item/第五范式/5025271)（5NF）和第六范式（6NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。

- 候选键：可以唯一确定一个元组的属性，可以是联合属性，候选码可以有多个。
- 主键：主键是人为规定的，从候选码中选的一个。
- 非主属性：不是主属性的属性都是非主属性。
- 主关系键：候选键
- 函数依赖：
	函数依赖是关系模式中属性之间的一种逻辑依赖关系。
	函数依赖需要了解部分函数依赖和传递函数依赖
- 部分函数依赖：
	在关系模式R中，X和Y是R关系的子集，X的真子集X’,有X’->Y,则称Y对X部分函数依赖。部分函数依赖是多值函数依赖
- 传递函数依赖
	在关系模式R中，X,Y,Z是U的子集，若X->Y,Y-/->X,Y->Z,则有Z对X传递函数依赖

> ###### 第一范式

第一范式(1NF)：每一列要保持原子特征 列是基本数据项，不能再进行拆分，否则设计成一对多的关系
不满足第一范式就不能称之为关系型数据库。

> ###### 第二范式

第二范式（2NF）：每个非主属性都完全函数依赖于R的主关系键，也就是说在第一范式的基础上，消除非主属性对主关系键的部分函数依赖，就可以成为第二范式。

> ###### 第三范式

第三范式（3NF）：每个非主属性都不传递函数依赖R的主关系键。也就是说在第二范式的基础上，消除非主属性对主关系键的传递函数依赖，就可以成为第三范式。

> ######  BC范式    


BC范式（BCNF）：消除主属性或非主属性对主关系键的部分函数依赖和传递函数依赖，就可以达到第三范式。仔细分析这句话，可以排除很多无关因素，因为要达到BC范式，这时关系肯定已经达到了第三范式：已经消除了非主属性对主关系键的部分函数依赖和传递函数依赖。一般主要考虑的是主属性对主关系键的部分函数依赖。

### 5.3 事务与锁

#### 5.3.1 事务的特性ACID

- **原子性(Atomic)**：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。
- **一致性(Consistency)**：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。
- **隔离性(Isolation)**：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，到底是另一个事务执行之前的状态还是中间某个状态，相互之间存在什么影响，是可以通过隔离级别的设置来控制的。
- **持久性(Durability)**：事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失，它对于系统的影响是永久性的。

#### 5.3.2 事务并发控制

- **第一类丢失更新（Update Lost）**：此种更新丢失是因为回滚的原因，所以也叫回滚丢失。此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了。
- **脏读（Dirty Read）**：此种异常时因为一个事务读取了另一个事务修改了但是未提交的数据。举个例子，事务一更新了count=101，但是没有提交，事务二此时读取count，值为101而不是100，然后事务一出于某种原因回滚了，然后第二个事务读取的这个值就是噩梦的开始。
- **不可重复读（Not Repeatable Read）**：此种异常是一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是在两次查询之间有别的事务对该行数据做了更新操作。举个例子，事务一先查询了count，值为100，此时事务二更新了count=101，事务一再次读取count,值就会变成101，两次读取结果不一样。
- **第二类丢失更新（Second Update Lost）**：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失。举个例子，两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了。
- **幻读（Phantom Read）**：幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读。

#### 5.3.3 事务隔离级别

- **读未提交（Read Uncommitted）**：该隔离级别指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。
- **读已提交（Read Committed）**：该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle,Sqlserver。
- **可重复读（Repeatable Read）**：该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读改行数据就禁止写，消除了不可重复读和第二类更新丢失，这是Mysql数据库的默认隔离级别。
- **串行化（Serializable）**：意思是说这个事务执行的时候不允许别的事务并发执行.完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。

| 级别\异常 | 第一类更新丢失 | 脏读 | 不可重复读 | 第二类丢失更新 | 幻读 |
| :-------- | :------------: | :--: | :--------: | :------------: | :--: |
| 读未提交  |       Y        |  Y   |     Y      |       Y        |  Y   |
| 读已提交  |       N        |  N   |     Y      |       Y        |  Y   |
| 可重复读  |       N        |  N   |     N      |       N        |  Y   |
| 串行化    |       N        |  N   |     N      |       N        |  N   |

#### 5.3.4 数据库中的锁

一般可以分为两类，一个是悲观锁，一个是乐观锁，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如hibernate实现的乐观锁甚至编程语言也有乐观锁的思想的应用。

> ##### **悲观锁**

顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。

悲观锁按照使用性质划分：

- **共享锁（Share locks简记为S锁）**：也称读锁，事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以同时读，但不能有写操作，直到A释放S锁。
- **排它锁（Exclusivelocks简记为X锁）**：也称写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。
- **更新锁（简记为U锁）**：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。

悲观锁按照作用范围划分：

- **行锁**：锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表user，有主键id和用户生日birthday当你使用update … where id=?这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用update … where birthday=?这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。
- **表锁**：锁的作用范围是整张表。

> ##### **乐观锁**

顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。

乐观锁实现方式：

- **版本号（记为version）**：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update … where … and version=”old version”这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。
- **时间戳（timestamp）**：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。
- **待更新字段**：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。
- **所有字段**：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新

乐观锁几种方式的区别：

新系统设计可以使用version方式和timestamp方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新version,也就是说两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行。旧系统不能修改数据库表结构的时候使用数据字段作为版本控制信息，不需要新增字段，待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高。

### 5.4 非关系型数据库

#### 5.4.1 非关系型数据库的类别

非关系型数据库都是针对某些特定的应用需求出现的，因此，对于该类应用，具有极高的性能。依据结构化方法以及应用场合的不同，主要分为以下几类：

- **面向高性能并发读写的key-value数据库：**
- 主要特点是具有极高的并发读写性能
	 Key-value数据库是一种以键值对存储数据的一种数据库，类似Java中的map。可以将整个数据库理解为一个大的map，每个键都会对应一个唯一的值。
	 **主流代表**：Redis， Amazon DynamoDB， Memcached， Microsoft Azure Cosmos DB和Hazelcast

- **面向海量数据访问的面向文档数据库：**

	主要特点是在海量的数据中可以快速的查询数据
	 文档存储通常使用内部表示法，可以直接在应用程序中处理，主要是JSON。JSON文档也可以作为纯文本存储在键值存储或关系数据库系统中。
	 **主流代表**：MongoDB，Amazon DynamoDB，Couchbase， Microsoft Azure Cosmos DB，CouchDB

- **面向搜索数据内容的搜索引擎：**
- 搜索引擎是专门用于搜索数据内容的NoSQL数据库管理系统。
	 主要是用于对海量数据进行近实时的处理和分析处理，可用于机器学习和数据挖掘
	 **主流代表：Elasticsearch，Splunk，Solr，MarkLogic，Sphinx**

- **面向可扩展性的分布式数据库：**

	主要特点是具有很强的可拓展性
	普通的关系型数据库都是以行为单位来存储数据的，擅长以行为单位的读入处理，比如特定条件数据的获取。因此，关系型数据库也被成为面向行的数据库。相反，面向列的数据库是以列为单位来存储数据的，擅长以列为单位读入数据。
	 该类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化，将数据存储在记录中，能够容纳大量动态列。由于列名和记录键不是固定的，并且由于记录可能有数十亿列，因此可扩展性存储可以看作是二维键值存储。
	 **主流代表：Cassandra，HBase，Microsoft Azure Cosmos DB， Datastax Enterprise，Accumulo**

#### 5.4.2 CAP理论

NoSQL的基本需求就是支持分布式存储，严格一致性与可用性需要互相取舍

 CAP理论：一个分布式系统不可能同时满足**C(一致性)**、**A(可用性)**、**P(分区容错性)**三个基本需求，并且最多只能满足其中的两项。对于一个分布式系统来说，分区容错是基本需求，否则不能称之为分布式系统，因此需要在C和A之间寻求平衡。

 C(Consistency)一致性 一致性是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。与ACID的C完全不同 A(Availability)可用性 可用性是指服务一直可用，而且是正常响应时间。 P(Partition tolerance)分区容错性 分区容错性是指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。**

